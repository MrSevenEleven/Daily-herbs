<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    class MyPromise {
        constructor(executor) {
            if (!this._isFunction(executor)) {
                throw new Error(`${executor} is not a function`);
            }
            this._status = "pending";
            this._value = undefined;
            this._handleFulfilled = [];
            this._handleRejected = [];
            // 很多文章在这里给executor加了try catch，实际上原生Promise的executor中的错误并没有捕获
            executor(this._resolve.bind(this), this._reject.bind(this));
        }
        _isFunction(val) {
            return Object.prototype.toString.call(val) === "[object Function]";
        }
        _resolve(value) {
            if (this._status === "pending") {
                this._status = "fulfilled";
                this._value = value;
                let cb;
                // 异步按顺序调用并清空回调
                setTimeout(() => {
                    while ((cb = this._handleFulfilled.shift())) {
                        cb(value);
                    }
                }, 0);
            }
        }
        _reject(value) {
            if (this._status === "pending") {
                this._status = "rejected";
                this._value = value;
                let cb;
                // 异步按顺序调用并清空回调
                setTimeout(() => {
                    while ((cb = this._handleRejected.shift())) {
                        cb(value);
                    }
                }, 0);
            }
        }
        then(onFulfilled, onRejected) {
            const self = this;
            const { _value, _status } = this;

            // 如果onFulfilled、onRejected不是函数，强制改为函数，并且该函数直接返回接收到的参数，传后面的then的回调函数
            onFulfilled = self._isFunction(onFulfilled) ? onFulfilled : (v) => v;
            onRejected = self._isFunction(onRejected) ? onRejected : (v) => v;

            return new MyPromise((resolve, reject) => {
                const fulfilled = (value) => {
                    const res = onFulfilled(value);
                    if (res instanceof MyPromise) {
                        res.then(resolve, reject);
                    } else {
                        resolve(res);
                    }
                };
                const rejected = (value) => {
                    const res = onRejected(value);
                    if (res instanceof MyPromise) {
                        // 这里是重点
                        res.then(resolve, reject);
                    } else {
                        // 注意这里是resolve(res)，而不是reject(res)
                        resolve(res);
                    }
                };
                switch (_status) {
                    case "pending":
                        self._handleFulfilled.push(fulfilled);
                        self._handleRejected.push(rejected);
                        break;
                    case "fulfilled":
                        fulfilled(_value);
                        break;
                    case "rejected":
                        rejected(_value);
                        break;
                    default:
                        throw new Error('Promise resolver Unverified status');
                }
            });
        }
    }

    let p1=new MyPromise((resolve,reject)=>{
        console.log('promise');
        setTimeout(()=>{
            resolve('success');
        },1000)
    }).then(()=>{
        console.log('then1')
    }).then(()=>{
        console.log('then2')
    })
</script>
</body>
</html>